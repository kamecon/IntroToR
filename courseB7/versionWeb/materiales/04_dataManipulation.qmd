---
title: "Data Frames"
format: html
execute:
  echo: true
  messages: false
  warning: false
editor: source
---

# Manipulación de datos: Operaciones básicas

```{r dfload}
#| message: false
#| echo: false
#| warning: false

library(dplyr)
library(readr)
library(tidyr)
library(data.table)

figarodf <- read.csv(file = "./data/icUse24ed2020.csv")
figarotb <- read_csv(file = "./data/icUse24ed2020.csv")
figarodt <- fread(file = "./data/icUse24ed2020.csv")


```


## Seleccionar columnas y filas

### R base

Como hemos visto en secciones anteriores, para acceder a elementos de un data frame, escribimos el nombre del data frame con corchetes y una coma `df[ , ]`. A la izquierda de la coma accedemos a las filas por su índice (localización), a la derecha accedemos a las columnas por su índice (posición) o nombre. Se pueden acceder a varias filas y columnas. En el caso que deseemos ver una columna o fila específica, dejamos una de las dimensiones en blanco

### dplyr

Recordemos que dplyr se basa en el uso de una gramática basada en _verbos_ en forma de funciones. Las funciones tienen nombres los suficientemente descriptivos de la labor que realizan.

La función `slice()` que nos permite extraer las filas de un data frame por índices.

Si lo que deseamos es seleccionar columnas, usamos el verbo `select()`

### data.table

Siguiendo un poco la lógica de la sintaxis de los data frames de R base, para seleccionar filas por índice usaremos el espacio delante de la primera de las 3 comas, y para seleccionar columnas ya sea por nombre o índice, el bloque a la derecha de la primera coma.

::: {.panel-tabset}

## R base

```{r dffilcol}
#Selecciona filas por índice

figarodf[1:5, ]

#No contiguas

figarodf[c(1,10,24598), ]

#Selecciona columnas por índice 

figarodf[ , 3:6] |> head()

#No contiguas

figarodf[ , c(2,8,12)] |> head()

#Por nombre

figarodf[ , "REF_AREA"] |> head()

#Ejemplo real: eliminar las filas de metadatos

figarodf[ , c("TIME_PERIOD", "REF_AREA", "ROW_PI", "COUNTERPART_AREA", "COL_PI", "OBS_VALUE" )] |> head()


```

## Dplyr

```{r dplyrfilcol}
#Selecciona filas por índice

figarotb |>  slice(1:5)

#No contiguas

figarotb |> slice(c(1,10,24598))

#Selecciona columnas por índice 

figarotb |> select(3:6)

#No contiguas

figarotb |> select(c(2,8,12))

#Por nombre

figarotb |> select(REF_AREA)

#Ejemplo real: eliminar las filas de metadatos

figarotb |> 
  select(TIME_PERIOD, REF_AREA, ROW_PI, COUNTERPART_AREA, COL_PI, OBS_VALUE)

```

## data.table

```{r datatablefilcol}
#Selecciona filas por índice

figarodt[1:5, ]

#No contiguas

figarodt[c(1,10,24598), ]

#Selecciona columnas por índice 

figarodt[ , 3:6] 

#No contiguas

figarodt[ , c(2,8,12)]

#Por nombre

figarodt[ , list(REF_AREA)] 

figarodt[ , .(REF_AREA)]

#Ejemplo real: eliminar las filas de metadatos

figarodt[ , .(TIME_PERIOD, REF_AREA, ROW_PI, COUNTERPART_AREA, COL_PI, OBS_VALUE)]


```

:::

En el caso de dplyr, la función `select()` ofrece opciones más amplias.

Supongamos que deseamos seleccionar solo las columnas que cumplan una determinada condición, esto se puede hacer con la función `where()` dentro del verbo `select()`. Por ejemplo, si deseamos solo las columnas que contengan variables numéricas en la tabla de productos


```{r dplyr14_2}

figarotb |>
  select(where(is.numeric))

```


Pero, también existen variantes de `select()` más específicas. Por ejemplo, para este caso también podríamos haber usado `select_if()` y la condición


```{r dplyr14_3}

figarotb |>
  select_if(is.character)

```


::: {.callout-tip}

Hay varias funciones *helpers* que permiten hacer una selección más fina de columnas. Para echar un vistazo ejecutar `?select`

:::

De nuevo, cabe resaltar que `dplyr` posee funciones que permiten operar sobre las columnas de manera cómoda, como por ejemplo renombrar y reorganizar

```{r dplyrcolumns}

#Renombrar columnas
figarotb |> 
  rename(Origin = REF_AREA, Destination = COUNTERPART_AREA)

#Cambiar columnas de posición
figarotb |> 
  relocate(COUNTERPART_AREA, .after = REF_AREA)

figarotb |> 
  relocate(where(is.numeric), .after = last_col())

```


En R base esto es algo menos amigable, pero es bueno saber como manipular el nombre de las columnas.

Si aplicamos la función `colnames()`, esta no es más que un vector de carácteres, del cual podemos extraer elementos

```{r basecolumns}

colnames(figarodf)

colnames(figarodf)[3]

colnames(figarodf)[c(4,6)]

```

Para replicar lo que hemos hecho con dplyr, hacemos lo siguiente

```{r basecolumns2}

colnames(figarodf)[c(4,6)] <- c("Origin", "Destination")

```

Reasignar filas es también menos directo, hay que suministrar al data frame una máscara con el nuevo orden

```{r basecolumns3}

nuevoOrden <- c("PROD_STAGE", "PRICES", "TIME_PERIOD", "Origin", "Destination", "ROW_PI",  "COL_PI", "OBS_VALUE", "UNIT_MULT", "DECIMALS", "UNIT_MEASURE", "OBS_STATUS", "CONF_STATUS", "LAST_UPDATE")

figarodf[ , nuevoOrden] |> head()

```

### Ordenar columnas

::: {.panel-tabset}

## R base

```{r basecolorder}

#Orden ascendente
figarodf[order(figarodf$ROW_PI), ] |> head()

#Orden descendente
figarodf[order(-figarodf$ROW_PI), ] |> head()


```


:::

## Seleccionar filas

La operación de seleccionar ciertas filas que cumplan una condición, puede que sea de las más frecuentes en el análisis de datos.

En el caso de las tres librerías, la estrategia es la misma, crear una _máscara_ a partir de una condición lógica.

Una condición lógica siempre devuelve `TRUE` o `FALSE`, la idea es que nos quedemos con aquellos elementos del data frame que cumplan la condición lógica, es decir, aquellos que sean `TRUE`

::: {.panel-tabset}

## R base

```{r dfrows}

#Seleccionar filas: condicion simple

figarodf[figarodf$REF_AREA == "AT", ] |> head()

#Seleccionar filas: condiciones simultaneas

figarodf[figarodf$REF_AREA == "AT" & figarodf$COUNTERPART_AREA == "AT", ] |> head()

figarodf[figarodf$REF_AREA == "AT" & figarodf$COUNTERPART_AREA != "AT", ] |> head()

figarodf[figarodf$REF_AREA %in% c("AT", "BE", "IT"), ] |> head()

figarodf[figarodf$REF_AREA %in% c("AT", "BE", "IT") & figarodf$COL_PI %in% c("P3_S13", "P3_S14", "P3_S15", "P51G", "P5M"), ] |>
  head()

```

## dplyr

```{r dplyrrows}

#Seleccionar filas: condicion simple

figarotb |> 
  filter(REF_AREA == "AT")

#Seleccionar filas: condiciones simultaneas

figarotb |> 
  filter(REF_AREA == "AT" & COUNTERPART_AREA == "AT")

figarotb |> 
  filter(REF_AREA == "AT" & COUNTERPART_AREA != "AT")

figarotb |> 
  filter(REF_AREA %in% c("AT", "BE", "IT"))

figarotb |> 
  filter(REF_AREA %in% c("AT", "BE", "IT") & COL_PI %in% c("P3_S13", "P3_S14", "P3_S15", "P51G", "P5M"))

figarotb |> 
  filter(REF_AREA %in% c("AT", "BE", "IT") & !COL_PI %in% c("P3_S13", "P3_S14", "P3_S15", "P51G", "P5M"))


```

## data.table

```{r dtrows}

#Seleccionar filas: condicion simple

figarodt[REF_AREA == "AT"]

#Seleccionar filas: condiciones simultaneas

figarodt[REF_AREA == "AT" & COUNTERPART_AREA == "AT"]

figarodt[REF_AREA == "AT" & COUNTERPART_AREA != "AT"] 

figarodt[REF_AREA %chin% c("AT", "BE", "IT")]

figarodt[REF_AREA %chin% c("AT", "BE", "IT") & COL_PI %chin% c("P3_S13", "P3_S14", "P3_S15", "P51G", "P5M")]

figarodt[REF_AREA %chin% c("AT", "BE", "IT") & !COL_PI %chin% c("P3_S13", "P3_S14", "P3_S15", "P51G", "P5M")]

```

:::




