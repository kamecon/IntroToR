---
title: "Data Frames"
format: html
execute:
  echo: true
  messages: false
  warning: false
editor: source
---

# Manipulación de datos: Operaciones básicas

```{r dfload}
#| message: false
#| echo: false
#| warning: false

library(dplyr)
library(readr)
library(tidyr)
library(data.table)

figarodf <- read.csv(file = "./data/icUse24ed2020.csv")
figarotb <- read_csv(file = "./data/icUse24ed2020.csv")
figarodt <- fread(file = "./data/icUse24ed2020.csv")


```


## Seleccionar columnas y filas

### R base

Como hemos visto en secciones anteriores, para acceder a elementos de un data frame, escribimos el nombre del data frame con corchetes y una coma `df[ , ]`. A la izquierda de la coma accedemos a las filas por su índice (localización), a la derecha accedemos a las columnas por su índice (posición) o nombre. Se pueden acceder a varias filas y columnas. En el caso que deseemos ver una columna o fila específica, dejamos una de las dimensiones en blanco

### dplyr

Recordemos que dplyr se basa en el uso de una gramática basada en _verbos_ en forma de funciones. Las funciones tienen nombres los suficientemente descriptivos de la labor que realizan.

La función `slice()` que nos permite extraer las filas de un data frame por índices.

Si lo que deseamos es seleccionar columnas, usamos el verbo `select()`

### data.table

Siguiendo un poco la lógica de la sintaxis de los data frames de R base, para seleccionar filas por índice usaremos el espacio delante de la primera de las 3 comas, y para seleccionar columnas ya sea por nombre o índice, el bloque a la derecha de la primera coma.

::: {.panel-tabset}

## R base

```{r dffilcol}
#Selecciona filas por índice

figarodf[1:5, ]

#No contiguas

figarodf[c(1,10,24598), ]

#Selecciona columnas por índice 

figarodf[ , 3:6] |> head()

#No contiguas

figarodf[ , c(2,8,12)] |> head()

#Por nombre

figarodf[ , "REF_AREA"] |> head()

#Ejemplo real: eliminar las filas de metadatos

figarodf[ , c("TIME_PERIOD", "REF_AREA", "ROW_PI", "COUNTERPART_AREA", "COL_PI", "OBS_VALUE" )] |> head()


```

## Dplyr

```{r dplyrfilcol}
#Selecciona filas por índice

figarotb |>  slice(1:5)

#No contiguas

figarotb |> slice(c(1,10,24598))

#Selecciona columnas por índice 

figarotb |> select(3:6)

#No contiguas

figarotb |> select(c(2,8,12))

#Por nombre

figarotb |> select(REF_AREA)

#Ejemplo real: eliminar las filas de metadatos

figarotb |> 
  select(TIME_PERIOD, REF_AREA, ROW_PI, COUNTERPART_AREA, COL_PI, OBS_VALUE)

```

## data.table

```{r datatablefilcol}
#Selecciona filas por índice

figarodt[1:5, ]

#No contiguas

figarodt[c(1,10,24598), ]

#Selecciona columnas por índice 

figarodt[ , 3:6] 

#No contiguas

figarodt[ , c(2,8,12)]

#Por nombre

figarodt[ , list(REF_AREA)] 

figarodt[ , .(REF_AREA)]

#Ejemplo real: eliminar las filas de metadatos

figarodt[ , .(TIME_PERIOD, REF_AREA, ROW_PI, COUNTERPART_AREA, COL_PI, OBS_VALUE)]


```

:::

En el caso de dplyr, la función `select()` ofrece opciones más amplias.

Supongamos que deseamos seleccionar solo las columnas que cumplan una determinada condición, esto se puede hacer con la función `where()` dentro del verbo `select()`. Por ejemplo, si deseamos solo las columnas que contengan variables numéricas en la tabla de productos


```{r dplyr14_2}

figarotb |>
  select(where(is.numeric))

```


Pero, también existen variantes de `select()` más específicas. Por ejemplo, para este caso también podríamos haber usado `select_if()` y la condición


```{r dplyr14_3}

figarotb |>
  select_if(is.character)

```


::: {.callout-tip}

Hay varias funciones *helpers* que permiten hacer una selección más fina de columnas. Para echar un vistazo ejecutar `?select`

:::

De nuevo, cabe resaltar que `dplyr` posee funciones que permiten operar sobre las columnas de manera cómoda, como por ejemplo renombrar y reorganizar

```{r dplyrcolumns}

#Renombrar columnas
figarotb |> 
  rename(Origin = REF_AREA, Destination = COUNTERPART_AREA)

#Cambiar columnas de posición
figarotb |> 
  relocate(COUNTERPART_AREA, .after = REF_AREA)

figarotb |> 
  relocate(where(is.numeric), .after = last_col())

```


En R base esto es algo menos amigable, pero es bueno saber como manipular el nombre de las columnas.

Si aplicamos la función `colnames()`, esta no es más que un vector de carácteres, del cual podemos extraer elementos

```{r basecolumns}

colnames(figarodf)

colnames(figarodf)[3]

colnames(figarodf)[c(4,6)]

```

Para replicar lo que hemos hecho con dplyr, hacemos lo siguiente

```{r basecolumns2}

figarodf_02 <- figarodf[sample(x = nrow(figarodf), size = 1000), ]

colnames(figarodf_02)[c(4,6)] <- c("Origin", "Destination")

head(figarodf_02)

```

Reasignar filas es también menos directo, hay que suministrar al data frame una máscara con el nuevo orden

```{r basecolumns3}

nuevoOrden <- c("PROD_STAGE", "PRICES", "TIME_PERIOD", "Origin", "Destination", "ROW_PI",  "COL_PI", "OBS_VALUE", "UNIT_MULT", "DECIMALS", "UNIT_MEASURE", "OBS_STATUS", "CONF_STATUS", "LAST_UPDATE")

figarodf[ , nuevoOrden] |> head()

```

### Ordenar columnas

::: {.panel-tabset}

## R base

```{r basecolorder}
set.seed(125L)

figarodfSmall <- figarodf[sample(x = nrow(figarodf), size = 1000), ]

#Orden ascendente
figarodfSmall[order(figarodfSmall$ROW_PI), ] |> head()

#Orden descendente
figarodfSmall[order(figarodfSmall$ROW_PI, decreasing = TRUE), ] |> head()

```

## dplyr 

```{r dplyrorder}

#Orden ascendente
figarotb |> 
  arrange(ROW_PI)

#Orden descendente
figarotb |> 
  arrange(desc(ROW_PI))


```

## data.table

```{r datatableorder}
#Orden ascendente
figarodt[order(ROW_PI)]

#Orden descendente
figarodt[order(-ROW_PI)]

```


:::

## Seleccionar filas

La operación de seleccionar ciertas filas que cumplan una condición, puede que sea de las más frecuentes en el análisis de datos.

En el caso de las tres librerías, la estrategia es la misma, crear una _máscara_ a partir de una condición lógica.

Una condición lógica siempre devuelve `TRUE` o `FALSE`, la idea es que nos quedemos con aquellos elementos del data frame que cumplan la condición lógica, es decir, aquellos que sean `TRUE`

::: {.panel-tabset}

## R base

```{r dfrows}

#Seleccionar filas: condicion simple

figarodf[figarodf$REF_AREA == "AT", ] |> head()

#Seleccionar filas: condiciones simultaneas

figarodf[figarodf$REF_AREA == "AT" & figarodf$COUNTERPART_AREA == "AT", ] |> head()

figarodf[figarodf$REF_AREA == "AT" & figarodf$COUNTERPART_AREA != "AT", ] |> head()

figarodf[figarodf$REF_AREA %in% c("AT", "BE", "IT"), ] |> head()

figarodf[figarodf$REF_AREA %in% c("AT", "BE", "IT") & figarodf$COL_PI %in% c("P3_S13", "P3_S14", "P3_S15", "P51G", "P5M"), ] |>
  head()

```

## dplyr

```{r dplyrrows}

#Seleccionar filas: condicion simple

figarotb |> 
  filter(REF_AREA == "AT")

#Seleccionar filas: condiciones simultaneas

figarotb |> 
  filter(REF_AREA == "AT" & COUNTERPART_AREA == "AT")

figarotb |> 
  filter(REF_AREA == "AT" & COUNTERPART_AREA != "AT")

figarotb |> 
  filter(REF_AREA %in% c("AT", "BE", "IT"))

figarotb |> 
  filter(REF_AREA %in% c("AT", "BE", "IT") & COL_PI %in% c("P3_S13", "P3_S14", "P3_S15", "P51G", "P5M"))

figarotb |> 
  filter(REF_AREA %in% c("AT", "BE", "IT") & !COL_PI %in% c("P3_S13", "P3_S14", "P3_S15", "P51G", "P5M"))


```

## data.table

```{r dtrows}

#Seleccionar filas: condicion simple

figarodt[REF_AREA == "AT"]

#Seleccionar filas: condiciones simultaneas

figarodt[REF_AREA == "AT" & COUNTERPART_AREA == "AT"]

figarodt[REF_AREA == "AT" & COUNTERPART_AREA != "AT"] 

figarodt[REF_AREA %chin% c("AT", "BE", "IT")]

figarodt[REF_AREA %chin% c("AT", "BE", "IT") & COL_PI %chin% c("P3_S13", "P3_S14", "P3_S15", "P51G", "P5M")]

figarodt[REF_AREA %chin% c("AT", "BE", "IT") & !COL_PI %chin% c("P3_S13", "P3_S14", "P3_S15", "P51G", "P5M")]

```

:::

## Crear nuevas variables (columnas)

En este punto las tres librerías difieren algo en su estrategia, pero los tres son bastante claros para el usuario  

::: {.panel-tabset}

## R base

```{r basenewcol}

figarodf$NEW_COLUMN <- figarodf$UNIT_MULT + figarodf$DECIMALS

figarodf$OBS_VALUE_WEIRD <- log(figarodf$OBS_VALUE)

head(figarodf)


```

## dplyr

```{r dplyrnewcol}

figarotb |> 
  mutate(NEW_COLUMN = UNIT_MULT + DECIMALS , OBS_VALUE_WEIRD = log(OBS_VALUE))

#Fijaros que en este caso no modificamos la tabla original a no ser que la guardemos en un objeto nuevo

```

## data.table

```{r datatablenewcol}

figarodt[, NEW_COLUMN := UNIT_MULT + DECIMALS]
figarodt[, OBS_VALUE_WEIRD := log(OBS_VALUE)]

# Al mismo tiempo
# figarodt[, `:=` (NEW_COLUMN = UNIT_MULT + DECIMALS,
#                  OBS_VALUE_WEIRD = log(OBS_VALUE))]

figarodt

```


:::

También es posible crear columnas contingentes, es decir, que su valor pertenezca a un conjunto reducido discreto y que dependa del valor de otra variable/columna. Esta s una práctica habitual en el análisis empírico para codificar variables que van a ser usadas en un modelo (NOTA: en R esto no hace falta en el análisis empírico porque existe el tipo de variable factor)


::: {.panel-tabset}

## R base

```{r basecase}

figarodf$NEW_PRODUCT <- ifelse(figarodf$ROW_PI %in% c("CPA_C29", "CPA_N78", "CPA_C21", "CPA_K64", "CPA_H53"),
                               "CPA_NEW",
                               figarodf$ROW_PI)

figarodf[figarodf$NEW_PRODUCT == "CPA_NEW", ] |> head()

```

## dplyr

```{r dplyrcase}

figarotb |> 
  mutate(NEW_PRODUCT = if_else(ROW_PI %in% c("CPA_C29", "CPA_N78", "CPA_C21", "CPA_K64", "CPA_H53"),
                               "CPA_NEW",
                               ROW_PI))

#Fijaros que en este caso no modificamos la tabla original a no ser que la guardemos en un objeto nuevo

```

## data.table

```{r datatablecase}

figarodt[, NEW_PRODUCT := fifelse(ROW_PI %in% c("CPA_C29", "CPA_N78", "CPA_C21", "CPA_K64", "CPA_H53"),
                               "CPA_NEW",
                               ROW_PI)]

figarodt

```

:::

Cuando tenemos condiciones múltiples, se puede anidar la función `ifelse()` del siguiente modo (solo hacemos el ejemplo en dplyr, pero es análogo en las otras dos opciones):

```{r dplyrcase2}

figarotb |> 
  mutate(NEW_PRODUCT2 = if_else(ROW_PI %in% c("CPA_C29", "CPA_N78", "CPA_C21", "CPA_K64", "CPA_H53"),
                                "CPA_NEW",
                                if_else(ROW_PI %in% c("CPA_C16", "CPA_Q86", "CPA_C28", "CPA_C19", "CPA_H50"),
                                        "CPA_NEW2",
                                        ROW_PI)
                                )
          )


```


Esta sintaxis es poco legible y se puede volver aún más confusa a medida que introducimos más condiciones

Afortunadamente, podemos usar la función `case_when()` en dplyr y `fcase()` en data.table

::: {.panel-tabset}

## dplyr

```{r dplyrcase3}

figarotb |> 
  mutate(NEW_PRODUCT3 = case_when(ROW_PI %in% c("CPA_C29", "CPA_N78", "CPA_C21", "CPA_K64", "CPA_H53") ~ "CPA_NEW",
                                  ROW_PI %in% c("CPA_C16", "CPA_Q86", "CPA_C28", "CPA_C19", "CPA_H50") ~ "CPA_NEW2",
                                  .default = ROW_PI)
         )

```


## data.table

```{r data.tablecase3}

figarodt[, NEW_PRODUCT3 := fcase(ROW_PI %in% c("CPA_C29", "CPA_N78", "CPA_C21", "CPA_K64", "CPA_H53"), "CPA_NEW",
                                 ROW_PI %in% c("CPA_C16", "CPA_Q86", "CPA_C28", "CPA_C19", "CPA_H50"), "CPA_NEW2",
                                 default = ROW_PI)]

figarodt

```

:::

Asimismno, además de ser mas legibles, este tipo de operaciones con `case_when()` y `fcase()` son más rápidas

Otra operación útil cuando manipulamos columnas es la de crear una columna de carácteres uniendo o separando otras dos columnas

En el caso de unir dos columnas de carácteres


::: {.panel-tabset}

## R base


```{r basepaste}

figarodf$IC_ROW <- paste(figarodf$REF_AREA, figarodf$ROW_PI, sep = "_")

head(figarodf)

#Para crear identificadores únicos

figarodf$IC_COL <- paste(figarodf$REF_AREA, figarodf$COL_PI, sep = "_")

figarodf$TRADE_ID <- paste(figarodf$IC_ROW, figarodf$IC_COL, sep = "_")

head(figarodf)


```



## dplyr

```{r dplyrcase3}

figarotb |> 
  mutate(NEW_PRODUCT3 = case_when(ROW_PI %in% c("CPA_C29", "CPA_N78", "CPA_C21", "CPA_K64", "CPA_H53") ~ "CPA_NEW",
                                  ROW_PI %in% c("CPA_C16", "CPA_Q86", "CPA_C28", "CPA_C19", "CPA_H50") ~ "CPA_NEW2",
                                  .default = ROW_PI)
         )

```


## data.table

```{r data.tablecase3}

figarodt[, NEW_PRODUCT3 := fcase(ROW_PI %in% c("CPA_C29", "CPA_N78", "CPA_C21", "CPA_K64", "CPA_H53"), "CPA_NEW",
                                 ROW_PI %in% c("CPA_C16", "CPA_Q86", "CPA_C28", "CPA_C19", "CPA_H50"), "CPA_NEW2",
                                 default = ROW_PI)]

figarodt

```

:::















