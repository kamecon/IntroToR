---
title: "Programación y Entorno de Trabajo para la IA: R"
author: "Kamal Romero"
date: "`r format(Sys.time(), '%m %d, %Y')`"
format:
  html: 
    toc: true
    toc-depth: 3
    toc-location: left
---

```{r libraries}
#| echo: false
#| warning: false

#Vamos a cargar las librerías con "pacman"

#Verificamos si esta instalado la libreria pacman, en caso que no lo este, se instala
if (! ('pacman' %in% installed.packages())) install.packages('pacman')

#Una vez instalada, este comando carga la libreria, y si no esta instalada, lo hace
pacman::p_load(wooldridge, dplyr, purrr, data.table, ggplot2, AER)

```


# Introducción

El objetivo del presente módulo es introducir al alumno al uso de R dentro del ciclo de trabajo para el análisis de datos con el objeto de crear herramientas que permitan la generación de valor a partir de la información cuantitativa generada por un proceso, ya sea un proceso físico derivado de la operación de dispositivo, o el generado a través de la interacción social implícita en las actividades comerciales.

El presente curso es introductorio y operativo, se pretende introducir las herramientas básicas y más populares que ofrece R para poder capturar, transformar, analizar, preparar para el modelaje y presentar los datos.

Asimismo, si el tiempo lo permite, conocer la integración de R con otras herramientas usadas habitualmente en los entornos del ciclo de trabajo de la IA.


# ¿Qué es R?

La siguiente definición es del libro [Learning R de Richard Cotton](https://www.oreilly.com/library/view/learning-r/9781449357160/):

"*Para confundirte, R se refiere a dos cosas. Está R, el lenguaje de programación, y R, el software que se utiliza para ejecutar programas escritos en R. Afortunadamente, la mayoría de las veces debería estar claro en el contexto a qué R se hace referencia.*"

"*R (el lenguaje) fue creado a principios de los 90 por Ross Ihaka y Robert Gentleman, ambos trabajaban en la Universidad de Auckland. Se basa en el lenguaje S desarrollado en los Laboratorios Bell en los años 70, principalmente por John Chambers. R (el software) es un proyecto GNU, lo que refleja su condición de importante software libre y de código abierto.*"

Características del lenguaje

-   Interpretado: permite ejecuciones directas del código, lo que lo hace más lento que los lenguajes compilados.
-   Tipado dinámicamente: Fácil y menos boiler plate, facilita mucho la metaprogramación.
-   Multiparadigma. Aunque la mayoría de los usuarios explotan la versión funcional y algunos la orientación a objetos.

# Entorno de trabajo

En este curso utilizaremos la herramienta online [Posit cloud](https://login.rstudio.cloud/login?redirect=%2F) de Posit.

[Rstudio](https://posit.co/download/rstudio-desktop/) es un IDE (entorno de desarrollo integrado) que funciona como una interfaz gráfica que facilita el uso del lenguaje R.

Posit Cloud en su versión online

::: {#fig-atomic}
![](rstudio.jpg)

Entorno de R studio
:::

## Entorno de trabajo: alternativas

Existen alternativas a Posit (algunos lo seguimos llamando Rstudio), pero este es el IDE de facto de R para muchos y el que seguramente se toparán en su actividad profesional.

Una alternativa que va ganando mucha popularidad es el conocido [Visual Studio Code](https://code.visualstudio.com/)

Si no desean usar Posit, esta sería la alternativa recomendada

## Entorno de trabajo: funcionamiento básico

A continuación, vamos a introducir manejos básicos del entorno de trabajo, tales como definir variables, realizar comentarios al código, etc. En este proceso, iremos introduciendo conceptos del lenguaje que iremos definiendo de manera formal más adelante

### Operaciones aritméticas

Para introducirnos al uso del editor y de la linea de comandos de Rstudio, empezaremos con unas operaciones muy básica

```{r operaciones}

2 + 2

5 - 3

3 * 2

6 / 3

```

Es posible aplicar reglas de asociación estándar así como operaciones más allá de las básicas (potencia, logaritmo, etc.)

```{r operaciones 2}

(5 + 3) / 4

3^2

log(100, base = 10)

sqrt(9)

```

### Asignación de variables

Podemos guardar *valores* asignándoles un nombre, de modo que podamos acceder a dicho valor posteriormente

```{r asigna}

x <- 4

x

y <- (5 + 3) / 4

y

```

Se crean variables, o crean nuevos *objetos* (puede que volvamos a esto luego) con el operador `<-`. También se puede hacer de la manera más convencional con `=`.

```{r asigna2}

Numero_de_empleados <- 150

Numero_de_empleados

```

Con los nombres hay que respetar ciertas convenciones: deben comenzar con una letra y solo pueden contener letras, números, `_` y `.`

Se es libre de nombrar las variables como uno prefiera, pero existen unas reglas de estilo, como por ejemplo

```{r librerias}
#| eval: false

yoUsoCamelCase
otros_usan_snake_case
algunos.usan.puntos
Lo_queMeSale.de.por_AHI

```

::: {#fig-elephant}
[![](https://cdn.myportfolio.com/45214904-6a61-4e23-98d6-b140f8654a40/dbb99049-2916-4bc8-824f-1816f5c4f06d_rw_1920.png?h=f0b45a30ba31ad414562d1085cd6c172)](https://allisonhorst.com/everything-else)

Una ilustración de los estilos con que nombrar variables hecho por la gran [Allison Horst](https://allisonhorst.com/allison-horst). La fuente es [esta](https://allisonhorst.com/everything-else).
:::

## Introducir comentarios

Se inician los comentarios con \#

```{r comentarios}

#Calculo del numero de empleados mas dos

Numero_de_empleados + 2


```

## Librerías

Las librerías o paquetes puede que sean los elementos de mayor uso en R para el trabajo práctico.

Una definición formal de una librería sacada del libro R Packages de Hadley Wickham y Jennifer Bryan es la siguiente:

"*En R, la unidad fundamental de código compartible es el paquete. Un paquete agrupa código, datos, documentación y pruebas, y es fácil de compartir con otros. En marzo de 2023, había más de 19.000 paquetes disponibles en Comprehensive R Archive Network, o CRAN, el centro público de intercambio de paquetes de R.*"

Un paquete de R es una manera de compartir código de una manera organizada y que expanden las posibilidades de R extendiendo las funcionalidades del mismo

Las librerías se instalan usando el comando `install.packages()`, y se cargan las librerías con `library()`

```{r libreria}
#| eval: false

install.packages(emoji)
library(emoji)


```

# Repaso a tipos/variables/estructuras en R

Cualquier análisis de IA empieza por la captura y el procesamiento de datos, sin esto, no hay flujo de trabajo
Para poder trabajar con datos, es necesario entender como los datos son almacenados en el ordenador por cada lenguaje de programación.

Las estructuras que almacenan información numérica, y la manera de acceder a ellas, difieren de Python a R, o de R a SAS.

La familia más importante de tipos de variable en R son los vectores, que pueden clasificarse en atómicos o listas.

La estructura de los vectores atómicos es la siguiente:

::: {#fig-atomic}
![](summary-tree-atomic.png){width=300}

Estructura de datos en R. Fuente: [Advanced R](https://adv-r.hadley.nz/index.html)
:::

Cuando decimos vectores, nos viene a la cabeza un arreglo del tipo vector columna o fila que conocemos del álgebra lineal básica.

También podemos pensar en arreglos multidimensionales del tipo de una matriz.

En R, existe la posibilidad de trabajar con matrices para poder almacenar datos con más de una dimensión de análisis

Tanto los vectores como las matrices solo pueden almacenar datos homogéneos, es decir, del mismo tipo

::: {.callout-note}

Enumere dos situaciones en la cual es interesante almacenar y analizar datos con más de una dimensión o atributo

:::

## Vectores atómicos

Un vector es un arreglo de una dimensión que almacena datos del mismo tipo, similar a los arrays de numpy, con la diferencia que son objetos nativos de R, no hay necesidad de llamar una librería.

```{r tipos}

Numero <-  1.0   # (real, flotante)
Entero <- 1L
Caracter <- "ab"   
Logico <- TRUE  

Numero
Entero
Caracter
Logico

```

Con lo anterior, ya hemos creado vectores en R de longitud o tamaño (volveremos a esto luego) 1.

Pero por lo general, solemos trabajar con vectores de más de una simple variable. Para construir esto, usamos la función `c()` que *combina* o *concatena* varios vectores independientemente de su tamaño

```{r vectores}

vector_numerico <- c(1, 10, 49)
vector_caracter <- c("a", "b", "c")
vector_de_vectores <- c(vector_numerico, c(8,3,12))


vector_numerico
vector_caracter
vector_de_vectores

```

```{r vectores2}

vector_mixto <- c(1,2,"a")
vector_mixto

```

En el ejemplo anterior hemos querido crear un vector con elementos de distintos tipos, numérico y carácter. R ha convertido todos los elementos a carácter.

Si hay caracteres en un vector R convierte todos los elementos a carácter, si todos son numéricos pero de distinto tipo, R los convierte al tipo de mayor precisión (doble).

El criterio de *coerción* de variables en R es el siguiente:

$$caracter > doble > entero> logico$$

::: {.callout-note}

Es posible realizar coerciones explícitas (definidas por el usuario) con las funciones `as.numeric()` `as.double()`  `as.integer()` `as.character()` y `as.logical()`

Pruebe las funciones anteriores con `vector_mixto` ¿Qué ocurre con los caracteres en este caso?

:::

Otras formas de crear vectores: las funciones `seq()` `rep()` `:` y vectores aleatorios

Función `seq()`

```{r vectores3}

vector_1 <- 1:5

vector_2 <- seq(1,5)

vector_3 <- seq(1,10, by = 2)

vector_4 <- seq(1,10, length.out = 20)

vector_5 <- seq(1,10, along.with = vector_1)

vector_1

vector_2

vector_3

vector_4

vector_5


```


Función `rep()`

```{r vectores4}

repetido_1 <- rep(4,10)

repetido_2 <- rep(1:4, 4)

repetido_3 <- rep(1:4, each = 4)

repetido_4 <- rep(1:4, each=2, times=2)

repetido_5 <- rep(1:4, c(2,3,4,5))

repetido_1

repetido_2

repetido_3

repetido_4

repetido_5

```

Vectores aleatorios

```{r vectores5}

aleatorio_normal <- rnorm(10)

aleatorio_uniforme <- runif(10)

aleatorio_normal

aleatorio_uniforme

```

::: {.callout-note}

Aprovechamos este tópico para introducir las **ayudas en R**. El ecosistema de librerías en R es muy amplio, lo cual a su vez implica muchas funciones. Podemos acceder a la documentación básica de la función a través de dos vías, escribiendo un signo de interrogación `?` antes de la función, o usando la función `help()`

Otras funciones similares a las anteriores para generar secuencias son `seq_along()` (usado mucho en los bucles) y `seq()`

Para conocer  su funcionamiento, ejecute los siguientes comandos:

`?seq_along`

`help("seq_len")`

:::

Otra característica de los vectores además de su tipo, es su **longitud** o dimensión, la cual podemos determinar con la función `length()`

```{r longitud}

length(vector_1)

length(vector_4)

length(repetido_5)

```

::: {.callout-note}

Pruebe las siguientes funciones en alguno de los vectores aleatorios: `sort()`, `rev()` y `unique()`

Busque en la ayuda que hace cada función, ¿alguna tiene argumentos adicionales?

:::


### Operaciones con vectores

Se pueden realizar operaciones con vectores

```{r vectores6}

vector_1

vector_3

(Vec_suma <- vector_1 +vector_3) #Si encerramos entre paréntesis una operación, aparece el resultado impreso en la consola

(Vec_producto <- vector_1 * vector_2)


```


En este caso, ambos vectores tienen la misma dimensión. ¿Qué ocurre si pasa lo contrario?

```{r vectores7}

vector_1 

seq(6,15)

vector_1 + seq(6,15)


```

Este comportamiento peculiar es lo que se denomina **reciclaje**. Observar el resultado ¿qué es lo que ha hecho R en este caso?


### Vectorización de operaciones

Decimos que una operación está vectorizada si la misma puede ser aplicada a todos los elementos de un vector

```{r vectorizacion}

vector_numerico

vector_numerico + 2

vector_numerico^2

sqrt(vector_numerico)

log(vector_numerico)


```

Observamos que cuando se aplica un operador aritmético (`+`, `*`, `-`, `/`, `^`) a un vector, la operación se realiza sobre cada uno de los elementos del vector. Del mismo modo, cuando aplicamos una función (`sqrt()`, `log()`) esta usa como argumentos todos los elementos del vector y su output es un vector de dimensión igual a la dimensión del vector original 

::: {.callout-note}

El abanico de funciones matemáticas de uso frecuente es relativamente amplio, revisar las siguientes que seguramente usaran mucho en el futuro

`abs()`
`exp()`
`cumsum()`
`cumprod()`
`sum()`
`prod()`
`min()`
`max()`
`mean()`
`sd()`

:::

### Inspección de vectores

Es posible aplicar ciertas funciones para analizar algunas características de los vectores.

Recordar que el objetivo último es el de realizar análisis de datos, algunas de estas funciones serán empleadas de manera regular cuando queramos inspeccionar los datos de una tabla 

Longitud de un vector

```{r inspect0}

length(vector_4)

```

Estadísticos de un vector

```{r inspect1}

summary(vector_4)

```

Valores al principio y al final

```{r inspect2}

head(vector_4)

tail(vector_4)

```

Valores máximos y mínimos

```{r inspect3}

max(aleatorio_normal)

min(aleatorio_normal)

```

Dónde están ubicados el máximo y el mínimo

```{r inspect4}

which.max(aleatorio_normal)

which.min(aleatorio_normal)

```

Lo anterior nos da el índice donde se encuentran los valores máximos y mínimos, usamos estos índices como máscaras para obtener los valores máximos y mínimos, que deberían coincidir con aquellos obtenidos con las funciones `min()` y `max()`

```{r inspect5}

aleatorio_normal[which.max(aleatorio_normal)]

aleatorio_normal[which.min(aleatorio_normal)]

```

### Selecciones

Este apartado es generalizable a otras estructuras de datos en R, como los data frames que son el principal contenedor de datos en el análisis de datos

Los vectores se encuentran indexados por su posición (**en R la primera posición de un array es uno, no cero**), lo que nos permite acceder a elementos puntuales del mismo usando dichos índices

¿Como accedemos a los elementos de un vector?

```{r select2}

vector_5

vector_5[1]

vector_5[3]

```

Varios elementos seguidos (slice)

```{r select3}

vector_5[1:3]

```

Varios elementos no seguidos

```{r select4}

vector_5[c(3,1)]

```

Todos los elementos excepto algunos

```{r select5}

vector_5[-c(1,3)]

```

También podemos seleccionar objetos con vectores lógicos o booleanos

```{r select5_1}

vector_5[c(TRUE, FALSE, FALSE, TRUE, FALSE)]

```

Y lo anterior es lo que nos permite escoger todos los elementos que cumplan una condición

```{r select6}

vector_5[vector_5 < 5]

```


Para acabar esta sección mencionamos que también podemos acceder a elementos de un vector a través de sus nombres, pero para poder hacer eso, el vector debe tener nombres de antemano

```{r vectornames}

vector_5

#El vector no tiene nombres

names(vector_5)

#Asignamos nombres construyendo un vector de caracteres de la misma longitud  que el vector que deseamos nombrar

names(vector_5) <- c("uno", "dos", "tres", "cuatro", "cinco")

vector_5

vector_5["dos"]

vector_5[c("uno", "cuatro")]

```

Es posible quitar los nombres de un vector con la función `unname()` usando el vector como argumento

Y aunque no entra en el apartado de selecciones, otra operación habitual que solemos realizar con vectores es ordenar sus elementos. Esto se realiza con la función `order()`

```{r vectororder01}

( order(aleatorio_normal) )

```

Lo anterior nos da los índices en los cuales se encuentran los elementos ordenados de menor a mayor. Para poder el vector debemos usar este vector resultante como una máscara en el vector original

```{r vectororder02}

( aleatorio_normal[order(aleatorio_normal)] )

```

Si deseamos ordenar de mayor a menor, colocamos un signo menos delante del nombre del vector usado como argumento en la función `order()`

```{r vectororder03}

( aleatorio_normal[order(-aleatorio_normal)] )

```



## Matrices y arreglos (arrays)

Los arreglos tabulares (organizados en filas y columnas) es de las principales formas en la que se organizan los datos, *independientemente de que el conjunto de datos tenga más de dos dimensiones*

Técnicamente, las matrices y los arreglos en R no son mas que vectores atómicos dotados de un atributo dimensión.

A diferencia de la advertencia del principio de la exposición de los vectores, las matrices **si** se pueden interpretar como el objeto de álgebra lineal, ya que el mismo es susceptible a operaciones matriciales como multiplicación de matrices, cálculo de inversa, diagonalización, et.

Y al igual que los vectores, no es necesario acceder a ningún paquete para realizar las operaciones de álgebra lineal.


### Creación de matrices

Las matrices se crean a partir de vectores, aunque también pueden crearse a partir de otras estructuras siempre y cuando tengan datos del mismo tipo

Las matrices se crean en R añadiendo un atributo dimensión `dim()`

```{r matriz0}

aleatorio_normal

dim(aleatorio_normal) <- c(2,5)

aleatorio_normal

```

En la práctica creamos matrices con la función `matrix()`

```{r matriz1}

#Fijamos una semilla para que el ejemplo sea reproducible
set.seed(123) 
#Creamos un vector aleatorio
( vector_matriz <-  runif(n = 20, min = 10, max = 50) )
#Redondeamos los elementos del vector
( vector_matriz <- round(vector_matriz) )

#Construimos la matriz

matrix(data = vector_matriz, nrow = 5, ncol = 4)

matrix(data = vector_matriz, nrow = 5, ncol = 4, byrow = TRUE)


```


Accedemos a los elementos de la matriz del mismo modo que los vectores 


```{r matriz2}

( matriz_1 <- matrix(data = vector_matriz, nrow = 5, ncol = 4, byrow = TRUE) )

matriz_1[3,2]

#Esto es nuevo, solo una (o varias) fila(s) o columna(s)
matriz_1[1,]

matriz_1[, 2:3]

matriz_1[2:3, 2:3]

```

Para obtener información de las dimensiones de una matriz, usamos las funciones `dim()`, `nrow()` y `ncol()`

```{r matriz2_5}

dim(matriz_1)

nrow(matriz_1)

ncol(matriz_1)

```

También podemos asignar nombres a las filas y columnas con las funciones que introduciremos a continuación

```{r matriz3}

( matriz_2 <- matriz_1[2:3, 2:3] )

#nombres de las columnas
colnames(matriz_2) <- c("columna 1", "columna 2")
rownames(matriz_2) <- c("fila 1", "fila 2")

matriz_2

matriz_2["fila 1", ]

```

::: {.callout-note}

Ejercicio:

Realice la misma operación que antes sobre `matriz_1` usando la función `dimnames()`

:::

Una operación que en la práctica se usa mucho, es la de crear una nueva *tabla* a partir de otra mediante la unión de filas y columnas. Esto se lleva a cabo con las funciones `rbind()` y `cbind()`

Si queremos añadir columnas basados en otra matriz:


```{r matriz4}

matriz_1

vector_matriz_2 <- round(runif(n = 10, min = 10, max = 50)) #Atentos a como hemos combinado dos funciones

( matriz_3 <-  matrix(data = vector_matriz_2, nrow = 5, ncol = 2, byrow = TRUE) )

cbind(matriz_1, matriz_3)

```

Si queremos añadir filas basados en otra matriz:

```{r matriz5}

matriz_1

vector_matriz_3 <- round(runif(n = 8, min = 10, max = 50)) 

( matriz_4 <-  matrix(data = vector_matriz_3, nrow = 2, ncol = 4, byrow = TRUE) )

rbind(matriz_1, matriz_4)

```



De un modo similar podemos construir un arreglo de más de dos dimensiones

```{r array1}

array(data = vector_matriz, dim = c(5,2,2))

```

::: {.callout-note}

Ejercicio:

Asigne nombres al array anterior usando la función `dimnames()`

:::

Como hemos mencionado antes, las matrices son objetos que pueden ser manipulados como matrices en el sentido del álgebra lineal. Por ejemplo, podemos calcular la transpuesta o la inversa de una matriz

Transpuesta

```{r matriz6}

matriz_1

t(matriz_1)

```

Inversa

```{r matriz6_5}

matriz_1

solve(matriz_1[1:4,1:4])

```



::: {.callout-note}

**Ejemplo: Regresión lineal**

Vamos a calcular los coeficientes estimados de una regresión lineal simple usando la solución analítica del problema de minimización de los residuos al cuadrado $\sum_{i=1}^n(y_i - \hat{y}_i)^2$

```{r matriz7}

#install.packages("wooldridge")
#library(wooldridge)

data(gpa1)

#Tamaño de la muestra y numero de regresores

n <- nrow(gpa1)
k <- 2


#Extraemos la variable independiente $y$


y <- gpa1$colGPA


#Construimos la matriz de regresores $X$ (en este caso 2) y añadimos una columna de unos


X <- cbind(1, gpa1$hsGPA, gpa1$ACT)


```

Estimamos los betas usando la expresión

$$\hat{\beta}=(X'X)^{-1}X'y$$

```{r matriz8}

beta_hat <- solve( t(X)%*%X ) %*% t(X)%*%y 
beta_hat


```


:::

El comando `solve` invierte la matriz, y la función `t()` ejecuta la transpuesta de una matriz y el operador `%*%` realiza productos de matrices, por lo que `solve( t(X)%*%X )` ejecuta la operación $(X'X)^{-1}$

::: {.callout-note}

Utilizar la ayuda para determinar que hacen las siguientes funciones de álgebra lineal

`det()`, `diag()`, `svd()`, `eigen()`, `qr()`, `chol()`

:::


## Listas

Lo que caracteriza a un vector atómico, es que solo puede almacenar datos homogéneos.

Las listas, son contenedores que permiten almacenar y manipular **datos heterogéneos** 

::: {.callout-note}

Enumere dos situaciones en la cual es interesante almacenar datos heterogéneos 

:::

Antes hemos definido los llamados **vectores atómicos**, que no es más que una forma de llamar a contenedores de variables homogéneas. Las listas son un tipo de *vectores* que permiten almacenar datos heterogéneos, llamados por algunos *vectores generalizados*.

Las listas se crean con la función `list()`

```{r listas1}

lista_1 <- list(vector_matriz, letters[1:10], matriz_1)

lista_1

```

En esta lista tenemos un vector numérico, un vector carácter y una matriz.

Al principio parece un objeto algo extraño, pero con el tiempo se aprende a apreciarlo debido a la versatilidad que este permite. No obstante, el objetivo de estas notas, no es hacer ejercicios aplicados con listas, sino, ver como la comprensión de la manipulación de listas (y vectores y matrices) nos permite entender mejor el comportamiento interno de los *data frames*.

Para acceder a los elementos de la lista, procederemos igual que en el caso de los vectores y arreglos, usando corchetes `[]`, pero a diferencia de las estructuras anteriores, hemos de tener en cuenta que las listas permiten almacenar objetos distintos.

Antes de continuar, observe como vemos la lista en la consola, los elementos numerados por doble corchetes `[[]]`

Probemos acceder al primer elemento

```{r listas2}

lista_1[1]

```

Pregunta, ¿esto sigue siendo una lista?, para verificar esto usamos la función `class()`

```{r listas3}

class(lista_1[1])

```

Si, sigue siendo una lista. Hemos extraído un vector numérico, probemos aplicar una operación con él

```{r listas3_5}
#| eval: false

( vector_lista <- lista_1[1] )

vector_lista^2

```

Obtenemos un error, aunque hemos en teoría extraído un vector numérico, no podemos operar con el.

Probemos acceder a dicho elemento usando dobles corchetes `[[]]`

```{r listas4}

( vector_lista_2 <-  lista_1[[1]] )

class(vector_lista_2)

vector_lista_2^2

```

Ahora si hemos podido, porque lo que hemos extraído es un vector numérico (como lo indica el otuput de `class()`)

Conclusión: los dobles corchetes `[[]]` permiten acceder al elemento de la lista en su tipo original, mientras que el corchete simple `[]` nos devuelve una lista solo con el elemento correspondiente. 

::: {.callout-note}

Una forma didáctica de como acceder a los elementos de una lista, se puede encontrar [acá](https://es.r4ds.hadley.nz/20-vectors.html#listas-de-condimentos) 

:::

En el caso del elemento de la lista que es una matriz

```{r listas5}

( matriz_lista_2 <-  lista_1[[3]] )

class(matriz_lista_2)

solve(matriz_lista_2[1:4, 1:4])

```

Ahora, si deseamos acceder a un elemento particular del elemento de la lista, lo hacemos de la manera habitual. 

Solemos acceder al tercer elemento de un vector usando `[3]` y la segunda columna de una matriz con `[ ,2]`, si están dentro de una lista, solo tenemos que extraer el elemento con el doble corchete `[[]]` y luego aplicar la selección habitual que corresponda a dicho elemento

```{r listas6}

lista_1[[1]]

lista_1[[1]][3]

lista_1[[3]]

lista_1[[3]][, 2]

```

Por lo general, es útil asignar nombres a las listas, lo cual además nos permitirá acceder a los elementos de la lista de una forma, para algunos, más cómoda.

Los nombres se asignan del mismo modo que a los vectores atómicos

```{r listas7}

names(lista_1) <- c("Numerico", "Caracter", "Matriz")

lista_1

```

Fijaros que ahora, cuando inspeccionamos la lista en la consola, ya no aparecen los dobles corchetes `[[]]` como antes, sino, un signo del dólar `$` con el nombre que hemos asignado a cada elemento.

Si ahora, deseamos acceder a un elemento de la lista por su nombre, lo haremos usando `$`

```{r listas8}

lista_1$Numerico

lista_1$Caracter

lista_1$Matriz

```

Seleccionamos elementos particulares de los elementos de la lista, del mismo modo que antes

```{r listas9}

lista_1$Numerico[3]

lista_1$Caracter[length(lista_1$Caracter)]

lista_1$Matriz[, 2]

```


## Data frames

Gran parte de los datos con los que trabajamos en el mundo de la ciencia de datos, están organizados en arreglos rectangulares, donde las filas representan las instancias, individuos u objetos de estudio, y las columnas las características de los mismos.  Esto implica que por definición, dado que las unidades de estudio se representan como entes multidimensionales, que las filas son heterogéneas (una fila es un individuo caracterizado, por ejemplo, por su edad, código postal de su residencia, saldo de su cuenta bancaria, etc.), y las columnas son homogéneas (la columna de edad son todos enteros si se representan en años) 

En R, el contenedor usado para poder realizar análisis sobre datos rectangulares, son los data frames.

Formalmente hablando, los data frames son **listas de vectores** de igual magnitud. Por lo que todo lo que hemos aprendido en las secciones anteriores, es aplicable a los data frames

### Inspeccionar los datos

Por lo general, solemos inspeccionar los datos de una tabla para familiarizarnos con ellos y ver que tipo de análisis podemos realizar con ellos.

Vamos a usar uno de los conjuntos de datos que ya viene en la instalación básica de R, `mtcars`


Podemos abrir una versión amigable de la tabla en RStudio

```{r df1}

mtcars

```

Existen varias formas de echar vistazos rápidos a los datos sin necesidad de visualizar la tabla entera

Por ejemplo podemos ver las 6 primeras filas

```{r df2}

head(mtcars)

```

O las 6 últimas

```{r df3}

tail(mtcars)

```

Si en lugar de 6, queremos ver un determinado número de filas, simplemente se lo decimos a las funciones `head`y `tail`

```{r df4}

head(mtcars, n = 3)

tail(mtcars, n = 2)

```

En el caso en que tengamos muchas columnas, la inspección visual es engorrosa, pero, al igual que las listas, si un data frame es una lista de vectores, donde los vectores son las columnas, podemos acceder a los nombres de las columnas usando `names()`

```{r df5}

names(mtcars)

```


Asimismo, un data frame es un objeto rectangular, es decir, con más de una dimensión, como una matriz, por lo que podremos obtener el número de filas y columnas con `dim()`

```{r df6}

dim(mtcars)

```

Podemos ver por separado el número de filas y columnas con `nrow` y `ncol`

```{r df7}

ncol(mtcars)

nrow(mtcars)

```


Otra forma es usando la función `str`. Aunque no es intuitiva e incluso intimida a primera vista, no es tan complicado y aporta información útil 

```{r df8}

str(mtcars)

```

Una versión que aporta información estadística es `summary`

```{r df9}

summary(mtcars)

```

Recordar que podíamos acceder a elementos de los vectores por posición o nombre

```{r df12}

head(mtcars, n = 1)

mtcars[1,2]

mtcars[1,4]

```

En el primer caso le decimos a R que queremos que nos muestre el dato de la primera fila y la segunda columna, en el segundo caso el dato de la primera fila y cuarta columna

En el caso que deseemos ver una columna o fila específica, dejamos una de las dimensiones en blanco

Si queremos acceder a la información de la segunda fila

```{r df13}

mtcars[2, ]

```

Si queremos acceder a la información de la cuarta columna

```{r df14}

mtcars[ , 4]

```

Tambien podemos obtener la información por columna usando el nombre de la misma

```{r df15}

mtcars[ , "cyl"]

```

Asimismo, podemos inspeccionar una columna de data frame escribiendo el nombre del mismo seguido de un signo `$` y el nombre de la columna

La ventaja de este método es que los nombres de la columna se autocompletan

```{r df16}

mtcars$cyl

```

Con la posición, al igual que los vectores, podemos acceder a conjuntos de filas y columnas (slices)

Por ejemplo, si nos queremos quedar solo con las 3 primeras filas y la cuarta y quinta columna

```{r df17}

mtcars[1:3, 4:5]

```

### Manipulación de data frames

Podemos añadir columnas a un data frame, usemos una versión reducida de `mtcars`

```{r df18}

(mtcars_mini <- mtcars[1:10, ])

```

Creamos un vector (con nombre) de caracteres de longitud 10

```{r df18_5}

( nueva_columna <- letters[1:10] )

```

Añadimos este vector como una nueva columna a `mtcars_mini`

```{r df19}

mtcars_mini$new <- nueva_columna

mtcars_mini

```

Como un data frame es un arreglo rectangular que nos permite utilizar funciones que hemos empleado antes con las matrices, otra forma de añadir una nueva(s) columna(s) es usando la función `cbind()`


```{r df20}

( new2 <- letters[11:20] )

( mtcars_mini <- cbind(mtcars_mini, new2) )

```

Asimismo podemos usar `rbind()` para añadir nuevas filas al data frame


```{r df21}

( rbind(mtcars_mini[, 1:(ncol(mtcars_mini)-2)], mtcars[11:15, ]) )

```

Prestar atención a lo que hemos hecho para poder adaptar mtcars_mini al número de columnas del sub conjunto de mtcars. 

Para aplicar la función `cbind()`hay que asegurarse que los data frames tengan el mismo número de filas, y para `rbind()` que tengan el mismo número de columnas.

Si queremos cambiar el orden de las columnas pasamos un vector de caracteres como máscara en la dimensión de columnas como máscara.

```{r df22}

orden_nuevo <- c("carb", "mpg",  "cyl",  "disp", "hp", "drat", "wt", "qsec", "vs",  "am", "gear")

mtcars[, orden_nuevo]

```

Si deseamos crear una nueva columna a partir de otras

```{r df23}

mtcars_mini$mpgOvercyl <- mtcars_mini$mpg / mtcars_mini$cyl

mtcars_mini

```


Y  podemos filtrar filas usando condiciones lógicas al igual que hacíamos con los vectores

```{r df24}

mtcars[mtcars$cyl > 4 & mtcars$hp > 100, ]

```

```{r df25}

mtcars[mtcars$cyl > 4 | mtcars$hp < 100, ]

```

```{r df26}

mtcars[mtcars$cyl == 6, ]

```

# Más allá de los data frames

Los data frames son una estructura extremadamente útil, con la gran ventaja de que forma parte del ecosistema de R base (no depende de librería elaboradas por terceros). Pero, lo anterior también representa también una restricción, por lo que se han desarrollado librerías que complementan las propiedades de los data frames

## El universo Tidyverse

::: {#fig-tidyverse}
![](tidyverse_website.png)

Colección de paquetes del ecosistema Tidyverse. Ver su [web](https://www.tidyverse.org/)
:::

La principal referencia de este apartado va a ser este [capítulo](https://r4ds.had.co.nz/transform.html) del libro [R for Data Science](https://r4ds.had.co.nz/index.html) (acá en [español](https://es.r4ds.hadley.nz/))

En esta primera parte de la exposición nos concentraremos en el paquete [dplyr](https://dplyr.tidyverse.org/) y en la manipulación de datos, e introduciremos el pipe de la librería [magrittr](https://magrittr.tidyverse.org/)

### Dplyr

::: {#fig-dplyr}
![](logo.png){width=200}

Hex sticker de dplyr
:::


En su página web, se presenta la librería dplyr como “*dplyr es una gramática de manipulación de datos, que proporciona un conjunto coherente de verbos que ayudan a resolver los problemas más comunes de manipulación de datos*” 

Otra definición se puede ver en este [texto](https://www.datanalytics.com/libro_r/1300_dplyr.html) de [Carlos Gil Bellosta](https://www.datanalytics.com/bio/) 

El “conjunto de verbos” es el siguiente:

* `mutate()` añade nuevas variables que son funciones de variables existentes
* `select()` selecciona variables basándose en sus nombres
* `filter()` selecciona casos basándose en sus valores
* `summarise()` reduce múltiples valores a un único resumen
* `arrange()` cambia el orden de las filas.

Al ser una librería desarrollada por terceros, hay que instalar la librería (se hace una sola vez) y cargarla

```{r dplyr01}
#| eval: false

install.packages("dplyr")
library(dplyr)

```


Vamos a trabajar con el conjunto de datos `starwars`

```{r dplyr02}

starwars

```

Observen que nuestro data frame ha *cambiado* de nombre, ahora es un `tibble`. Leer este capítulo del [libro](https://es.r4ds.hadley.nz/10-tibble.html) para una exposición detallada.

Inspeccionamos el data frame (si, el tibble sigue siendo un data frame) con `glimpse`

```{r dplyr03}

glimpse(starwars)

```

Antes de continuar, es mejor presentar ya el *pipe* de [magrittr](https://magrittr.tidyverse.org/). Empezaremos con un ejemplo simple en el cual deseamos calcular el logaritmo de la raíz cuadrada de la sumatoria de una secuencia de 20 realizaciones de una distribución uniforme.

Los pasos serían los siguientes:

* Generar la secuencia de 20 realizaciones de una distribución uniforme `runif(20)`
* Calcular la sumatoria `sum(runif(20)))`
* Obtener la raíz cuadrada `sqrt(sum(runif(20)))`
* Aplicar el logaritmo `log(sqrt(sum(runif(20))))` 


```{r dplyr04}

set.seed(356)
log(sqrt(sum(runif(20))))

```

La función es algo complicada de leer, y se complica su lectura a medida que añadimos más funciones.

El **pipe** (tubería) de magrittr `%>%` parte de la misma idea que el pipe de bash `|`, pasar el output de la salida de una función a otra función de manera encadenada.

Una manera “limpia” de ejecutar varios verbos de manera secuencial es a través del uso del pipe 

Según su web, dicha herramienta permite hacer nuestro código más legible por las siguientes razones:

* estructurando secuencias de operaciones de datos de izquierda a derecha (en lugar de dentro a fuera)

* evitando las llamadas a funciones anidadas

* minimizando la necesidad de variables locales y definiciones de funciones

* facilitar añadir pasos en cualquier punto de la secuencia de operaciones

La operación anterior quedaría de la siguiente forma con pipes:

```{r dplyr05}

set.seed(356)

runif(20) %>% 
  sum() %>% 
  sqrt() %>% 
  log()


```

Lo cual, es más natural y fácil de leer. Vamos a aplicar este encadenamiento de funciones con el pipe de manera intensiva con dplyr



Vamos a seleccionar filas que cumplan una determinada condición, esto se hace con el verbo `filter()`

Por ejemplo, nos quedamos solo con los personajes de Star Wars que son de Tatooine

```{r dplyr06}
starwars %>% 
  dplyr::filter(homeworld == "Tatooine")


```

O que viva en Tatooine y sean de género masculino 

```{r dplyr07}
starwars %>%
  dplyr::filter(homeworld == "Tatooine" & gender == "masculine") 

```


O queremos quedarnos con aquellos registros que no sean humanos 

```{r dplyr08}

starwars |> 
  dplyr::filter(species != "Human")

```
Si lo que deseamos es seleccionar columnas, usamos el verbo `select()`

Siguiendo con el primer ejemplo, queremos saber que personajes de Star Wars son de Tatooine, pero solo queremos ver la columna del nombre del personaje

```{r dplyr09}

starwars %>% 
  dplyr::filter(homeworld == "Tatooine") %>%
  select(name)


```

Además del nombre, queremos saber su altura y la especie

```{r dplyr10}

starwars %>% 
  dplyr::filter(homeworld == "Tatooine") %>%
  select(name, height, species)

```

Supongamos que no sabemos de antemano, cuantos tipos de especies hay, y deseamos saberlo para aplicar los filtros adecuados. En R base tendríamos que extraer la columna y usar la función `unique()` (`unique(starwars$species)`). En dplyr tenemos la función `distinct()`


```{r dplyr11}

starwars |> 
  select(species) |> 
  distinct()

```

Si queremos contar cuantos registros hay por especie, usamos la función `count()`

```{r dplyr12}

starwars |> 
  count(species)

```

Si deseamos que presente la información en orden descendente


```{r dplyr12_5}

starwars |> 
  count(species, sort = TRUE)

```

Si una vez escogida la columna deseada, desea ordenarla como en la caso anterior, usamos el verbo `arrange()`. En este caso seleccionamos la columna de masa corporal y nombre

```{r dplyr13}

starwars %>%
  select(name, mass) %>%
  arrange(mass)

```

Para ordenarlo de mayor a menos usamos la función `desc()` dentro de `arrange()`

```{r dplyr14}

starwars %>%
  select(name, mass) %>%
  arrange(desc(mass))

```

Supongamos que deseamos seleccionar solo las columnas que cumplan una determinada condición, esto se puede hacer con la función `where()` dentro del verbo `select()`. Por ejemplo, si deseamos solo las columnas que contengan variables numéricas

```{r dplyr14_2}

starwars %>%
  select(where(is.numeric))

```

Pero, también existen variantes de `select()` más específicas. Por ejemplo, para este caso también podríamos haber usado `select_if()` y la condición

```{r dplyr14_3}

starwars %>%
  select_if(is.numeric)

```

::: {.callout-note}

Hay varias funciones *helpers* que permiten hacer una selección más fina de columnas. Para echar un vistazo ejecutar `?select`

:::

Algo que solemos realizar de manera muy frecuente, es crear nuevas columnas transformando las existentes, esto lo hacemos con el verbo `mutate()`

```{r dplyr15}

starwars |> 
  mutate(H_W = height / mass)

```

Es posible crear varias columnas al mismo tiempo

```{r dplyr16}

starwars |> 
  mutate(H_W = height / mass,
         fakeVar = sqrt(mass))

```

Y para finalizar este exceso resumido paso por dplyr, presentamos dos verbos de los más usado en el ciclo de análisis de datos: `group_by()` y `summarise()`

Para los que conocen SQL, los dos verbos anteriores son el equivalente a un `GROUP BY` y una operación de agregación 

Por ejemplo, supongamos que queremos obtener la altura media por género

```{r dplyr17}

starwars |> 
  group_by(gender) |> 
  summarise(altura_media = mean(height, na.rm = TRUE))


```

O el peso medio por planeta de origen

```{r dplyr18}

starwars |> 
  group_by(homeworld) |> 
  summarise(peso_medio = mean(mass, na.rm = TRUE))

```

Recordar que lo podemos ordenar

```{r dplyr19}

starwars |> 
  group_by(homeworld) |> 
  summarise(peso_medio = mean(mass, na.rm = TRUE)) |> 
  arrange(desc(peso_medio))

```
Número de registros por planeta ordenado de mayor a menor

```{r dplyr20}

starwars |> 
  group_by(homeworld) |> 
  summarise(registros = n()) |> 
  arrange(desc(registros))

```

Y para finalizar, si deseamos cambiar el nombre de una columna, usamos la función `rename()`, y para cambiar el orden de las columnas `relocate()`

```{r dplyr21}

starwars |> 
  rename(planeta = homeworld)

```

```{r dplyr22}

starwars |> 
  relocate(species, .after = mass)

```

Algo adicional que conviene saber y combina bien con las funciones `map`, los tibbles anidados. Los tibbles anidados se crean con el verbo `nest_by()`

```{r dplyr23}

starwars_nested <- starwars |>
  nest_by(homeworld)

starwars_nested

```

Se accede al tibble anidado con la sintaxis de una lista

```{r dplyr23_5}

starwars_nested$data[[40]]

```


### Más allá de los tibbles: joins

Acabamos esta sección abarcando un problema con el cual ya se han topado en módulos anteriores, el hecho de que es común trabajar con más de una tabla de datos que guardan relación entre si, por lo que recurrimos a los ya conocidos JOINS y sus variantes.

También podemos realizar estas operaciones en tidyverse con las siguientes funciones:

* left_join()

* right_join() 

* inner_join() 

* full_join() 

* anti_join()

* semi_join() 

::: {.callout-note}

Una buena introducción a los joins (uniones) con dplyr es  [esta](https://es.r4ds.hadley.nz/13-relational-data.html#mutating-joins). Y para una comparación con R base y SQL [esto](https://es.r4ds.hadley.nz/13-relational-data.html#otras-implementaciones)

:::

Vamos a usar un ejemplo de juguete para mostrar los joins más básicos. Creamos dos conjuntos de datos usando la función `tibble()`

```{r joins00}

df_A <- tribble(
  ~ID, ~y,
   "A", 5,
   "B", 5,
   "C", 8,
   "D", 0,
   "F", 9)
df_B <- tribble(
  ~ID, ~z,
   "A", 30,
   "B", 21,
   "C", 22,
   "D", 25,
   "E", 29)

df_A

df_B

```


* Left join

```{r joins01}

left_join(x = df_A, y = df_B, by = "ID")

```

* Right join

```{r joins02}

right_join(x = df_A, y = df_B, by = "ID")

```

* Inner join

```{r joins03}

inner_join(x = df_A, y = df_B, by = "ID")

```

* Full join

```{r joins04}

full_join(x = df_A, y = df_B, by = "ID")

```

¿Qué ocurre si las columnas tienen nombres distintos?

```{r joins05}

colnames(df_B)[1] <- "KL"

full_join(x = df_A, y = df_B, by = c("ID"="KL"))

```


## data.table: The need for speed

::: {#fig-datatble}
![](logo4.png){width=200}

Hex sticker de data.table
:::

Ya que nos hemos empapado de parte del tidyverse, vamos a aprender la otra gran alternativa a los data frames estructura de R base, la librería data.table

Antes de empezar a analizar esta librería, primero habría que preguntarse ¿Por qué debemos aprender otras alternativas ya teniendo R base y el tidyverse? 

data.table posee unas ventajas idiosincráticas que la hacen una alternativa atractiva. Según los mismos desarrolladores de la librería, data.table:

“*es un paquete extremadamente rápido y eficiente en memoria para transformar datos en R.*”

Siguiendo a [Carlos Gil Bellosta](https://www.datanalytics.com/bio/), tal y como menciona en su [texto](https://www.datanalytics.com/libro_r/1300_dplyr.html):

“*El tidyverse no es el único dialecto popular de R. Por ejemplo, el paquete data.table propone otro dialecto con características muy distintas. El código en dicho dialecto es mucho menos legible pero tiene una ventaja importante: es increíblemente rápido y gestiona muy bien la memoria. Es un paquete (o dialecto) con el que conviene familiarizarse para trabajar con conjuntos de datos muy grandes, de millones, decenas de millones o, incluso de cientos de millones de filas*”

Y finalizamos con esta afirmación de [Grant McDermott](https://grantmcdermott.com/), profesor de la Universidad de Oregon y consultor de analítica de grandes datos

“_El tidyverse es genial (…) Entonces, ¿por qué molestarse en aprender otro paquete/sintaxis de gestión de datos? En lo que respecta a data.table, se me ocurren al menos cinco razones_:

* _Conciso_ 

* _Increíblemente rápido_

* _Uso eficiente de memoria_

* _Rico en funciones (y estable)_

* _Sin dependencias_”

Mi opinión personal es muy concreta, data.table es muy rápido y eficiente a la hora de manejar una gran cantidad de datos que aún no hayan pasado el límite para convertirse en Big Data.

Pero nada es gratuito, como menciona Gil Bellosta, la sintaxis es menos amigable si la comparamos con la del tidyverse.

La sintaxis de data table se puede resumir mediante el siguiente diagrama:

::: {#fig-tablesintax}
![](datatable.jpg){width=200}

Sintaxis de data.table
:::

* <span style="color:green;">i</span> indica las filas que deseamos seleccionar ya sea para filtrar o para ejecutar una operación sobre ese subconjunto de filas. El equivalente a <span style="color:green;">filter()</span>, <span style="color:green;">slice()</span> y <span style="color:green;">arrange()</span> en dplyr o <span style="color:green;">WHERE</span> en SQL

 * <span style="color:blue;">j</span> indica ya sea las columnas que deseamos seleccionar o la operación que deseamos realizar sobre las columnas. El equivalente a <span style="color:blue;">select()</span>; <span style="color:blue;">mutate()</span> en dplyr o <span style="color:blue;">SELECT</span> o las funciones de agregación en SQL

* <span style="color:red;">by</span> indica como debemos agregar el conjunto de datos. El equivalente a <span style="color:red;">group_by()</span> en dplyr o <span style="color:red;">GROUP BY</span> en SQL

Vamos a replicar los ejemplos de la sección anterior para poder realizar una comparación directa

Primero, instalamos la librería y la llamamos posteriormente

```{r datatable01}
#| eval: false

install.packages(data.table)
library(data.table)

```

Convertimos `starwars` a un objeto `data.table`

```{r datatable02}

starwars_dt <- as.data.table(starwars)

starwars_dt 

```

Observar que la presentación de la tabla en la consola es distinta a la de un tibble que a su vez era distinta a la de un data frame

Empezamos, nos quedamos solo con los personajes de Star Wars que son de Tatooine


```{r datatable03}

starwars_dt[homeworld == "Tatooine"]

```

Que viva en Tatooine y sean de género masculino

```{r datatable04}

starwars_dt[homeworld == "Tatooine" & gender == "masculine"]

```

Solo los registros que no sean humanos

```{r datatable05}

starwars_dt[species != "Human"]

```

También podemos seleccionar filas por posición, por ejemplo las 6 primeras filas

```{r datatable05_5}

starwars_dt[1:6]

```


Ahora seleccionamos columnas, recordar que para eso debemos usar el segundo argumento

```{r datatable06}

starwars_dt[homeworld == "Tatooine", list(name)]

```

Tenemos que pasar los nombres de las columnas como una lista, afortunadamente podemos usar el alias `.`

```{r datatable07}

starwars_dt[homeworld == "Tatooine", .(name)]

```

Si pasamos el nombre solamente, nos devuelve un vector en lugar de un data table

```{r datatable08}

starwars_dt[homeworld == "Tatooine", name]

```

::: {.callout-note}

Pruebe lo anterior con dos columnas, ¿Qué devuelve? ¿Tiene lógica?

Ahora intente con tres columnas ¿Por qué cree que tiene un error?

Intente lo anterior pasando un vector de caracteres con los nombres de las columnas que desea seleccionar

:::

Más columnas

```{r datatable09}

starwars_dt[homeworld == "Tatooine", .(name, height, species)]

```

Si deseamos ordenar el data table según alguna columna en particular

```{r datatable10}

starwars_dt[, .(name, mass)][order(mass)]

```

Observamos dos cosas nuevas:

La primera, si no vamos a realizar una operación sobre las filas, la *casilla* de ese argumento queda en blanco, y en el segundo argumento seleccionamos las columnas.

Lo segundo, una vez seleccionadas las columnas de interés, queremos operar sobre las filas, asi que necesitamos *encadenar* esa operación abriendo unos nuevos corchetes y operando sobre el primer argumento que es de la fila.


Para ordenar de manera descendente

```{r datatable11}

starwars_dt[, .(name, mass)][order(-mass)]

```

Para seleccionar solo las columnas que cumplan una determinada condición, por ejemplo, si deseamos solo las columnas que contengan variables numéricas, la operación es algo más verbosa

```{r datatable12}

starwars_dt[, .SD, .SDcols = is.numeric]

```
Acá introducimos dos elementos nuevos: `.SD` se emplea para hacer sub conjuntos del data table, definidos por las columnas enunciadas en `.SDcols`. A primera vista no es intuitivo, veremos un ejemplo menos trivial

Supongamos que queremos calcular la media de las columnas numéricas

```{r datatable13}

starwars_dt[, lapply(.SD, mean, na.rm = TRUE), .SDcols = is.numeric]

```

O solo a dos columnas

```{r datatable13_5}

starwars_dt[, lapply(.SD, mean, na.rm = TRUE), .SDcols = c("height", "mass")]

```

En data table creamos nuevas columnas transformando las existentes con `:=`

```{r datatable14}

starwars_dt[, H_W := height / mass][]

```

Es posible crear varias columnas al mismo tiempo

```{r datatable15}

starwars_dt[, `:=` (H_W = height / mass,
                    fakeVar = sqrt(mass))][]

```

Y para realizar operaciones de agrupación en data table

```{r datatable16}

starwars_dt[, .(altura_media = mean(height, na.rm = TRUE)), by = gender]

```

# Introducción a la visualización en R con `ggplot2`

La visualización de datos es un tópico independiente al que habría que dedicarle un cuatrimestre o incluso un curso entero.

Es un elemento fundamental en el ciclo del análisis de datos, que ocupa un sitio tanto al principio, durante y al final del mismo.

Dada la naturaleza práctica e interactiva de este módulo, el mismo se basará más en sesiones de código que en discusiones de naturaleza teórica,

Abarcaremos las funcionalidades de visualización de la librería `ggplot2` del ecosistema tidyverse.

ggplot2 ha sido usado por medios como la [BBC](https://bbc.github.io/rcookbook/) y el [Financial Times](https://blog.revolutionanalytics.com/2018/06/ft-bbc-uses-r.html)

::: {#fig-datatble}
![](logo5.png){width=200}

Hex sticker de ggplot2
:::

::: {.callout-note}

**Referencias bibliográficas**

Como se ha mencionado, en este curso veremos una (extremadamente) breve introducción a visualización con ggplot2. así que, a los interesados en profundizar en el tema les recomiendo la siguiente bibliografía:

+ Básica

  - [R Graphics Cookbook](https://r-graphics.org/), 2nd edition de Winston Chang. Es un libro de referencia en forma de recetario que es muy útil a la hora de intentar resolver dudas básicas (y no tanto) muy concretas.

  - [Data Visualization A practical introduction](https://socviz.co/) de Kieran Healy. Es una obra más extensa pero muy recomendable que va más allá del mero aprendizaje de una librería y trata los elementos de una buena visualización.

+ Complementaria

  - [ggplot2: Elegant Graphics for Data Analysis (3e)](https://ggplot2-book.org/) de  Hadley Wickham, Danielle Navarro, y Thomas Lin Pedersen. Este “es” el libro si desea aprender no el uso práctico de la librería ggplot2, sino la filosofía de la Gramática de Gráficos detrás de la librería. No será una referencia para este curso, pero es una cita obligatoria en cualquier curso que use ggplot2
  
  - [The Grammar of Graphics](https://link.springer.com/book/10.1007/0-387-28695-0?source=post_page-----1f92b4ed4149--------------------------------) de Leland Wilkinson. El libro de la *gramática de los gráficos*, filosofía debajo de la librería ggplot2. Recomendable para cualquiera que le interese la visualización en general.

:::

Instalamos y cargamos la librería 

```{r ggplot01}
#| eval: false

install.packages(ggplot2)
library(ggplot2)

```

Vamos a usar conjuntos de datos que trae la librería ggplot2 como ejemplo, empezamos con `mpg`

```{r ggplot02}

mpg

```

La estructura mínima de un gráfico necesita de un conjunto de datos, una geometría y una estética


```{r ggplot03}
#| eval: false

ggplot(data = <DATOS>, mapeo = aes(<MAPEO>)) + <GEOMETRIA>(OPCIONES)

```

La geometría sería el tipo de gráfico (dispersión, líneas, barras, etc.) y la estética sería como mapeamos los datos en los ejes, básicamente, que colocamos en los ejes.

La función necesaria para realizar el gráfico es `ggplot()`

Vamos a construir un gráfico que relacione las variables `displ` y `hwy`. Lo primero que necesitamos hacer es llamar los datos e indicarle que variables que deseamos representar, a esto último es lo que ggplot llama *estéticas* 


Dentro de la estética podemos añadir más opciones:

* `color` el color de la geometría y si está es contingente a una tercera variable

* `fill` el color del relleno de la geometría en caso de que esta sea una forma que pueda *rellenarse* (barras, puntos, polígonos, etc.)

* `shape`indica la forma de los puntos (pares ordenados o n-tuplas de las variables representadas) o las líneas que los unen

* `size` tamaño de la geometría

* `alpha` transparencia de la geometría


```{r ggplot035}

grafico <- ggplot(mpg, aes(x = displ, y = hwy)) 

grafico

```

Vemos que nos representa una especie de lienzo donde están representadas las variables a representar. Necesitamos una geometría o *capa*

```{r ggplot04}

grafico <- ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point()

grafico

```

Añadimos un color a la geometría que sea contingente a la variable discreta del conjunto de datos `class`

```{r ggplot05}

grafico <- ggplot(mpg, aes(x = displ, y = hwy, color = class)) +
  geom_point()

grafico

```

Asimismo, podemos incluir una forma para cada par ordenado que sea contingente a otra variable, en este caso `cyl`. Antes de incluirla la convertimos en un factor 

```{r ggplot06}

grafico <- ggplot(mpg, aes(x = displ, y = hwy, color = class, shape = factor(cyl))) +
  geom_point()

grafico

```

Podemos modificar el tamaño de la estética

```{r ggplot065}

grafico <- ggplot(mpg, aes(x = displ, y = hwy, color = class, shape = factor(cyl))) +
  geom_point(size = 3)

grafico

```

La verdad, este gráfico genera más confusión que otra cosa. Volvamos a nuestra versión simple, y vamos a elegir la forma de la estética con `shape`. Cada forma disponible tiene un número que puede consultar [acá](https://ggplot2.tidyverse.org/articles/ggplot2-specs.html#point)

```{r ggplot07}

grafico <- ggplot(mpg, aes(x = displ, y = hwy, color = factor(cyl))) +
  geom_point(size = 3, shape = 23)

grafico

```

Mejos nos quedamos con los círculos un poco más grandes

```{r ggplot08}

grafico <- ggplot(mpg, aes(x = displ, y = hwy, color = factor(cyl))) +
  geom_point(size = 4, shape = 21)

grafico

```

Vamos a quedarnos solo con los coches distintos a 5 cilindros (son muy pocos), y así vemos como podemos manipular el conjunto de datos dentro de las instrucciones del gráfico

```{r ggplot09}
#| class-source: "numberLines"
#| source-line-numbers: "1"

grafico <- ggplot(mpg |> dplyr::filter(cyl != 5),
                  aes(x = displ, y = hwy, color = factor(cyl))) +
  geom_point(size = 4, shape = 21)

grafico

```

Y ahora, vamos a estimar una relación lineal entre las variables `hmy` y `disp` por cilindros

```{r ggplot10}
#| warning: false

grafico <- ggplot(mpg |> dplyr::filter(cyl != 5),
                  aes(x = displ, y = hwy, color = factor(cyl))) +
  geom_point(size = 4, shape = 21) +
  geom_smooth(method = lm)

grafico

```

Y si deseamos que la relación sea no lineal, no especificamos el método (no lineal es el que viene por defecto)

```{r ggplot11}
#| warning: false

grafico <- ggplot(mpg |> dplyr::filter(cyl != 5),
                  aes(x = displ, y = hwy, color = factor(cyl))) +
  geom_point(size = 4, shape = 21) +
  geom_smooth()

grafico

```

Creo que nos quedaremos con la aproximación lineal en este caso, aún así, no es cómodo verlo en un solo gráfico. Para estos casos podemos definir *facetas* con `facet_grid()`

```{r ggplot12}
#| warning: false

grafico <- ggplot(mpg |> dplyr::filter(cyl != 5),
                  aes(x = displ, y = hwy, color = factor(cyl))) +
  geom_point(size = 4, shape = 21) +
  geom_smooth(method = lm) +
  facet_grid( ~ cyl)

grafico

```

```{r ggplot13}
#| warning: false

grafico <- ggplot(mpg |> dplyr::filter(cyl != 5),
                  aes(x = displ, y = hwy, color = factor(cyl))) +
  geom_point(size = 4, shape = 21) +
  facet_grid(class ~ cyl)

grafico

```

Vamos con más gráfico de estadística descriptiva propia de un EDA.

Un histograma

```{r ggplot14}
#| warning: false

grafico_h <- ggplot(mpg, aes(x = cty)) +
  geom_histogram()

grafico_h

```

```{r ggplot15}
#| warning: false

grafico_h <- ggplot(mpg, aes(x = cty)) +
  geom_histogram(binwidth = 3)

grafico_h

```

```{r ggplot16}
#| warning: false

grafico_h <- ggplot(mpg, aes(x = cty)) +
  geom_histogram(binwidth = 3, fill = "blue", color = "black")

grafico_h

```


Un boxplot

```{r ggplot17}
#| warning: false

grafico_b <- ggplot(mpg, aes(x =factor(cyl), y = hwy)) +
  geom_boxplot()

grafico_b

```

Finalmente, como ponemos títulos y etiquetas a nuestros gráficos

```{r ggplot18}

grafico <- ggplot(mpg |> dplyr::filter(cyl != 5),
                  aes(x = displ, y = hwy, color = factor(cyl))) +
  geom_point(size = 4, shape = 21) +
  labs(title = "Mi Primer Gráfico",
       subtitle = "Con ggplot",
       caption = "Fuente: Yo mismo") +
  xlab("Cilindrada") +
  ylab("Millas por galón")

grafico

```


# Una (extremadamente) breve introducción a la modelización en R

## Modelos lineales (regresión lineal)

La estimación lineal en R base se realiza con la función `lm()`

Los argumentos básicos de esta función son un conjunto de datos y una *formula* que indique a la función que variables deseamos relacionar

Vamos a usar como ejemplo, el mismo conjunto de datos usado en la sección de matrices

Cargamos e inspeccionamos los datos de la librería `Wooldridge`

```{r lm01}

data("wage1")

head(wage1)

summary(wage1)

str(wage1)

```

Estimamos un modelo lineal que explique el logaritmo del salario como función de los años de educación, la experiencia y años en la empresa actual.


```{r lm02}

modelo_1 <- lm(data = wage1, lwage ~ educ + exper + tenure)

summary(modelo_1)

```

## Regresión logística

La regresión logística se puede interpretar como un modelo de regresión no lineal que puede lidiar con variables dependientes binarias, o como un modelo de clasificación que pretende predecir una respuesta cualitativa.

En R base, usamos la función `glm()` para estimar modelos lineales generalizados

Presentamos un ejemplo usando una base de datos de aprobación de créditos bancarios. Exploramos los datos

```{r glm01}

data("HMDA")

head(HMDA)

summary(HMDA)

str(HMDA)

```


Estimamos un regresión logística que intente explicar los factores que determinan la probabilidad de que un crédito sea rechazado como función del ratio de pagos sobre ingreso y la etnia, en este caso, si se es afroamericano o no.


```{r glm02}

modelo_2 <- glm(data = HMDA, formula = deny ~ pirat + afam , family = binomial(link = logit))

summary(modelo_2)

```
